---
title: "Snippets"
author: "Anne"
date: "8-1-2020"
output: html_document
---
### tryCatch
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
inputs = list(1, 2, 4, -5, 'oops', 0, 10)
for(input in inputs) {
    tryCatch(print(paste("log of", input, "=", log(input))),
             warning = function(w) 
               {print(paste("negative argument", input)); 
                                      log(-input)},
             error = function(e) 
               {print(paste("non-numeric argument", input));
                               NaN})
}

(r <- seq_along(1:3))
             
```
<div style="margin-bottom:40px;">
</div>
## R for Data Science 
## by Hadley Wickham 
### Exercises Chapter 1: Data visualization with ggplot2
```{r include = T}
## p. 6
library(tidyverse)
# 1.
ggplot(data = mpg)
# an empty plot! No layers defined.

# 2. 
nrow(mtcars)
ncol(mtcars)

# 3. 
?mpg

# 4. Scatterplot of hwy versus cyl
ggplot(mpg, aes(x = hwy, y = cyl)) +
  geom_point()

## p.12 

# 1.
ggplot(data = mpg) +
  geom_point(
    mapping = aes(x = displ, y = displ), color = "pink"
  )

# 2. see class of each variable with glimpse()

# 5. What does stroke do
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 21, colour = "black", fill = "white", size = 2, stroke = 4)

# 6. Map aesthetic to sth other than a variable name 
ggplot(mpg, aes(x = displ, y = hwy, colour = displ < 6)) +
  geom_point()


```

### Exercises Chapter 3: Data transformation with dplyr 
** *filter* - choose certain variables only, like filter(flights, month >= 7, month <= 9)
  + with %in%: filter(flights, month %in% 7:9)
  + with booleans: filter(flights, dest == "IAH" | dest == "HOU")
  + with between: filter(flights, between(month, 7, 9))
  + with is.na: filter(flights, is.na(dep_time))
** *arrange* - sort values 
  + sorting in ascending order: arrange(flights, dep_delay)
  + to put NA first: arrange(flights, desc(is.na(dep_time)), dep_time)
** *mutate* -  calculate new variables and add them
  + like fastest_flights <- mutate(flights, mph = distance / air_time * 60)
  + transmute() > keep only new variables 
  + flights_deptime <-
  mutate(flights,
    dep_time_min = (dep_time %/% 100 * 60 + dep_time %% 100) %% 1440,
    sched_dep_time_min = (sched_dep_time %/% 100 * 60 +
      sched_dep_time %% 100) %% 1440,
    dep_delay_diff = dep_delay - dep_time_min + sched_dep_time_min
  )
** *select* - select columns by name
  + select by variable name: fastest_flights <- select(
  fastest_flights, mph, distance, air_time,
  flight, origin, dest, year, month, day
)
  + select by column names as strings: select(flights, "dep_time", "dep_delay", "arr_time", "arr_delay")
  + select by column numbers: select(flights, 4, 6, 7, 9)
  + Specify the names of the variables with character vector and one_of(): 
    + variables <- c("dep_time", "dep_delay", "arr_time", "arr_delay")
    + select(flights, one_of(variables))
  + starts_with: select(flights, starts_with("dep_"), starts_with("arr_"))
  + matches: select(flights, matches("^(dep|arr)_(time|delay)$"))
  + contains: select(flights, contains("_time"), contains("arr_"))
  + case-sensitive selection: ignore.case = FALSE
** *ranking*
  + row_number(): equivalent to row index 
  + min_rank(): assigns a rank equal to the number of values less than that tied value plus one
  + dense_rank(): assigns a rank equal to the number of distinct values less than that tied value plus one
  
** *trigonometry* 
  ++ sin, cos, tan, pi (see package Trig)

``` {r include = T, echo = T}

TRUE | FALSE
FALSE | NA
library(nycflights13)
library(tidyverse)
nycflights13::flights
## a) flights with a delay of two hours or more
names(nycflights13::flights)
(delay2hours <- filter(flights, arr_delay >= 120))

## b) flew to Houston 
hou <- (houst <- filter(flights, dest %in% c("IAH", "HOU")))

## g) departed between midnight and 6am
flights$time_hour

## Logarithms can be practical 
log(99999)
log(9)

## group_by() 
# creates grouping variable
# to use variable normally afterward, call ungroup()


## lag and lead
x <- c(1,1,2,2,3,4,5,6,6,7,8,9,9)
lag(x)
lead(x)
x != lag(x)

if (require("nycflights13")) {
carriers <- group_by(flights, carrier)
summarise(carriers, n())
mutate(carriers, n = n())
filter(carriers, n() < 100)
}

carriers <- group_by(flights, carrier) 

## Convert dep_time and sched_dep_time to more convenient representation of number of minutes since midnight 
flights$dep_time
flights$sched_dep_time

10 %% 2.4

## Handle weird values -> plot them! 
install.packages("ggplot2")
library(ggplot2)
ggplot(
  filter(flights_deptime, dep_delay_diff > 0),
  aes(y = sched_dep_time_min, x = dep_delay_diff)
) +
  geom_point()


## counts 
# whenever you aggregate data, use a count to make sure that you are not making conclusions based on very small amounts of data 
flights <- nycflights13::flights
names(flights)
library(dplyr)
not_cancelled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))

cancelled <- flights %>% 
  filter(is.na(dep_delay), is.na(arr_delay))
View(cancelled)

unsure <- flights %>% 
  filter(is.na(dep_delay), is.na(arr_delay))
View(unsure)

names(not_cancelled)
delays <- not_cancelled %>%
  group_by(month, flight, minute) %>% 
  summarize(
    delay = mean(arr_delay), delay_sd = sd(arr_delay),
    n = n()
  )

library(ggplot2)
ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)


delays %>% 
  filter(n > 2) %>% 
  ggplot(mapping = aes(x = n, y = delay)) +
  geom_point(alpha = 1/4)

## progressively rolling up summaries
library(tidyverse)
names(per_day)
daily <- group_by(flights, year, month, day)
(per_day <- dplyr::summarize(daily, count = n()))
(per_month <- dplyr::summarize(per_day, count = n()))
(per_month <- dplyr::summarize(per_day, count = n()))
(per_month <- dplyr::summarize(per_month, count = n()))

## ungrouping 
# if grouping needs to be removed, use ungroup()

daily %>% 
  ungroup() %>%  # no longer grouped by date 
  dplyr::summarize(flights = n())

## arrange - out NA first
arrange(flights, desc(is.na(dep_time)), dep_time) ## this works since TRUE > FALSE (1 > 0)

## mutate - sort to find the fastest flights 
(fastest_flights <- mutate(flights, mph = distance / air_time * 60))
fastest_flights <- select(
  fastest_flights, mph, distance, air_time,
  flight, origin, dest, year, month, day
)
head(arrange(fastest_flights, desc(mph)))

```

```{r include = T, echo = T}
### Exercises
names(flights)
desti <- dplyr::group_by(flights, dep_delay, arr_delay, origin)
(per_desti <- dplyr::summarize(desti, mean = mean(dep_delay)))

# how can you specify the following in a different way?: 
library(dplyr)
(not_cancelled %>% count(dest)) 
not_cancelled %>% count(tailnum, wt = distance) # wt denotes column for which should be summed 

nrow(not_cancelled %>% count(tailnum, wt = distance))
?count
names(not_cancelled)
(dest <- group_by(not_cancelled, dest)) 
(summi <-  dplyr::summarize(dest, n = n()))

(taili <- group_by(not_cancelled, tailnum))
(summi <- dplyr::summarise(taili, n = sum(distance)))

## tally: Any arguments to tally() are summed: 
not_cancelled %>%
  group_by(tailnum) %>%
  tally(distance)

## 5.6.4 
# cancelled flights 
cancelled <- flights %>% 
  filter(is.na(dep_delay), is.na(arr_delay))

names(cancelled)
cancelled %>% 
  group_by(day, arr_delay) %>%
  summarise(n = n())

?summarise

(cancelled_per_day <-
  flights %>%
  mutate(cancelled = (is.na(arr_delay) | is.na(dep_delay))) %>%
  group_by(year, month, day) %>%
  summarise(
    cancelled_num = sum(cancelled),
    flights_num = n(),
  ))

library(ggplot2)
ggplot(cancelled_per_day) +
  geom_point(aes(x = flights_num, y = cancelled_num))

names(cancelled_per_day)

(cancelled_and_delays <-
  flights %>%
  mutate(cancelled = (is.na(arr_delay) | is.na(dep_delay))) %>%
  group_by(year, month, day) %>%
  summarise(
    cancelled_prop = mean(cancelled),
    delay_prop = mean(dep_delay, na.rm = T),
    sth = mean(distance, na.rm = T),
  )) %>%
  ungroup()

ggplot(cancelled_and_delays) +
  geom_point(aes(x = delay_prop, y = cancelled_prop))

names(cancelled_and_delays)
(cancelled_and_delays_month <-
  cancelled_and_delays %>%
  group_by(year, month) %>%
  summarise(
    cancelled_pr = sum(cancelled_prop)
  )) %>%
  ungroup()

## 5.6.5 Which carrier has the worst delays? 
names(flights)
(flights %>% 
  group_by(carrier) %>% 
  summarise(depdel = mean(dep_delay, na.rm = T),
            arrdel = mean(arr_delay, na.rm = T)) %>% 
    arrange(desc(depdel))
  )
(flights %>% 
    group_by(carrier, dest) %>% 
    summarise(n()))

## disentangle effects of bad carriers and bad airports 
library(dplyr)
names(flights)
(bam <- (flights %>%
  filter(!is.na(arr_delay)) %>%
  # Total delay by carrier within each origin, dest
  group_by(origin, dest, carrier) %>%
  summarise(
    arr_delay = sum(arr_delay),
    flights = n()
  )))
# Total delay within each origin dest
tam <-  group_by(bam, origin, dest) %>%
  mutate(
    arr_delay_total = sum(arr_delay),
    flights_total = sum(flights))
# average delay of each carrier - average delay of other carriers
tam %>%
  mutate(
    arr_delay_others = (arr_delay_total - arr_delay) /
      (flights_total - flights),
    arr_delay_mean = arr_delay / flights,
    arr_delay_diff = arr_delay_mean - arr_delay_others
  ) %>%
# remove NaN values (when there is only one carrier)
filter(is.finite(arr_delay_diff)) %>%
# average over all airports it flies to
group_by(carrier) %>%
  summarise(arr_delay_diff = mean(arr_delay_diff)) %>%
  arrange(desc(arr_delay_diff))

?is.finite
## remove NaN with is.finite()
  
## What does the sort argument count() do? 
# It sorts the results in order of n. You could use this anytime you would run count() followed by arrange()
  
count(flights)
  
## Grouped Mutates (and filters)
# Grouping is most useful in conjunction with summarise(), but you can also use it with mutate() and 
# filter()
  
# find the worst members in a group
  
flights %>%
  group_by(year, month, day) %>%
  select(year, month, day, arr_delay, carrier) %>%
  filter(rank(desc(arr_delay)) < 10 )
  
## find all groups bigger than a threshold 
names(flights)
(popular_dest <- flights %>%
    group_by(dest) %>%
    filter(n() > 365) %>%
    summarize(mean = mean(arr_delay, na.rm =T))) 
head(arrange(popular_dest, desc(mean)))
      
names(flights)
(unpopular_dest <- flights %>%
group_by(dest) %>%
    filter(n() < 365) %>%
    summarize(mean = mean(arr_delay, na.rm =T))) 
head(arrange(unpopular_dest, desc(mean)))
      
## standardize to compute per group metrics:
(popular_dest <- flights %>% 
    filter(arr_delay > 0) %>%
    mutate(prop_delay = arr_delay/ sum(arr_delay)) %>%
    select(year:day, dest, arr_delay, prop_delay))
      
## a grouped filter is a grouped mutate followed by an ungrouped filter 
# functions that work most naturally in grouped mutates and filters are called 
# window functions (versus summary functions for summaries)

vignette("window-functions")

```

**How do mutate and filtering functions change when combined with grouping?**
** Summary functions (mean()), offset functions (lead(), lag()), ranking functions (min_rank(), row_number()), operate within each group when used with group_by() in mutate() or filter(). Arithmetic operators (+, -), logical operators (<, ==), modular arithmetic operators (%%, %/%), logarithmic functions (log) are not affected by group_by.
\n
** Summary functions like mean(), median(), sum(), std() and others covered in the section "Useful Summary Functions" calculate their values within each group when used with mutate() or filter() and group_by().

```{r include = T, echo=FALSE}
library(dplyr)

## different means, depending on whether overall mean is called or group mean (by group_by)
tibble(
  x = 1:9,
  group = rep(c("a", "b", "c"), each = 3)
) %>%
  mutate(x_mean = mean(x)) %>%
  group_by(group) %>%
  mutate(x_mean_2 = mean(x))

## Arithmetic operators are not affected by group_by()

tibble(
  x = 1:9,
  group = rep(c("a", "b", "c"), each = 3)
) %>%
  mutate(y = x + 2) %>%
  group_by(group) %>%
  mutate(z = x + 2)

## The modular arithmetic operators %/% and %% are not affected by group_by()
tibble(
  x = 1:9,
  group = rep(c("a", "b", "c"), each = 3)
) %>%
  mutate(y = x %% 2) %>%
  group_by(group) %>%
  mutate(z = x %% 2)

## The logarithmic functions log(), log2(), and log10() are not affected by group_by().

tibble(
  x = 1:9,
  group = rep(c("a", "b", "c"), each = 3)
) %>%
  mutate(y = log(x)) %>%
  group_by(group) %>%
  mutate(z = log(x))

## The offset functions lead() and lag() respect the groupings in group_by(). The functions lag() and lead() will only return values within each group.
tibble(
  x = 1:9,
  group = rep(c("a", "b", "c"), each = 3)
) %>%
  mutate(lag_a = lag(x)) %>%
  group_by(group) %>%
  mutate(
    lag_x = lag(x),
    lead_x = lead(x)
  )


```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
